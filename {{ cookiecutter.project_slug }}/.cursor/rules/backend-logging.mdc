---
description:
globs: *.py
alwaysApply: false
---
## Setup
- Use `structlog` for structured logging
- Access logger like so:
```python
from {{ cookiecutter.project_slug }}.utils import get_{{ cookiecutter.project_slug }}_logger

logger = get_{{ cookiecutter.project_slug }}_logger(__name__)
```

## Logging Levels
- **INFO**: Successful operations, key business events
- **DEBUG**: Detailed diagnostic information (not in production)
- **WARNING**: Recoverable errors, deprecations, fallback scenarios
- **ERROR**: Errors that don't crash the application
- **CRITICAL**: Errors that may crash the application

## Best Practices

### Success Logging
```python
# After successful API calls
logger.info(
    "API call successful",
    service="typefully",
    endpoint="/api/posts",
    status_code=200,
    response_id=result.get("id"),
    duration_ms=elapsed_time
)
```

### Error Logging

```python
logger.error(
    "API call failed",
    service="typefully",
    endpoint="/api/posts",
    error=str(e),
    status_code=getattr(response, 'status_code', None),
    exc_info=True  # Include stack trace
)
```

### Security & Privacy
- Never log: passwords, tokens, API keys, PII
- Safe to log: sanitized IDs, status codes, non-sensitive metadata

### Structured Fields
- Use consistent field names: user_id, request_id, service, endpoint
- Include context: timing, request identifiers, business relevant data
- Keep messages human-readable but supplement with structured data
- Try to use these alwaya, when possible:
    - email
    - profile_id

## Examples

```python
# Function entry/exit (DEBUG level)
logger.debug("Starting user authentication", user_id=user_id)

# Business events (INFO level)
logger.info("User logged in", user_id=user_id, login_method="oauth")

# Warning scenarios
logger.warning("Rate limit approaching", service="api", remaining_calls=5)

# Error with context
logger.error(
    "Database connection failed",
    database="primary",
    retry_attempt=3,
    error=str(e),
    exc_info=True
)
```
